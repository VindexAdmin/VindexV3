"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-keypairs";
exports.ids = ["vendor-chunks/ripple-keypairs"];
exports.modules = {

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/index.js":
/*!********************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeSeed = exports.deriveNodeAddress = exports.deriveAddress = exports.verify = exports.sign = exports.deriveKeypair = exports.generateSeed = void 0;\nconst ripple_address_codec_1 = __webpack_require__(/*! ripple-address-codec */ \"(ssr)/../../node_modules/ripple-address-codec/dist/index.js\");\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return ripple_address_codec_1.decodeSeed; } }));\nconst ripemd160_1 = __webpack_require__(/*! @xrplf/isomorphic/ripemd160 */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/ripemd160/index.js\");\nconst sha256_1 = __webpack_require__(/*! @xrplf/isomorphic/sha256 */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/sha256/index.js\");\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst utils_2 = __webpack_require__(/*! ./signing-schemes/secp256k1/utils */ \"(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\");\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ./utils/Sha512 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst assert_1 = __importDefault(__webpack_require__(/*! ./utils/assert */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst getAlgorithmFromKey_1 = __webpack_require__(/*! ./utils/getAlgorithmFromKey */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js\");\nconst secp256k1_1 = __importDefault(__webpack_require__(/*! ./signing-schemes/secp256k1 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js\"));\nconst ed25519_1 = __importDefault(__webpack_require__(/*! ./signing-schemes/ed25519 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js\"));\nfunction getSigningScheme(algorithm) {\n    const schemes = { 'ecdsa-secp256k1': secp256k1_1.default, ed25519: ed25519_1.default };\n    return schemes[algorithm];\n}\nfunction generateSeed(options = {}) {\n    assert_1.default.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');\n    const entropy = options.entropy\n        ? options.entropy.slice(0, 16)\n        : (0, utils_1.randomBytes)(16);\n    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';\n    return (0, ripple_address_codec_1.encodeSeed)(entropy, type);\n}\nexports.generateSeed = generateSeed;\nfunction deriveKeypair(seed, options) {\n    var _a;\n    const decoded = (0, ripple_address_codec_1.decodeSeed)(seed);\n    const proposedAlgorithm = (_a = options === null || options === void 0 ? void 0 : options.algorithm) !== null && _a !== void 0 ? _a : decoded.type;\n    const algorithm = proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';\n    const scheme = getSigningScheme(algorithm);\n    const keypair = scheme.deriveKeypair(decoded.bytes, options);\n    const messageToVerify = Sha512_1.default.half('This test message should verify.');\n    const signature = scheme.sign(messageToVerify, keypair.privateKey);\n    /* istanbul ignore if */\n    if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n        throw new Error('derived keypair did not generate verifiable signature');\n    }\n    return keypair;\n}\nexports.deriveKeypair = deriveKeypair;\nfunction sign(messageHex, privateKey) {\n    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPrivateKey)(privateKey);\n    return getSigningScheme(algorithm).sign((0, utils_1.hexToBytes)(messageHex), privateKey);\n}\nexports.sign = sign;\nfunction verify(messageHex, signature, publicKey) {\n    const algorithm = (0, getAlgorithmFromKey_1.getAlgorithmFromPublicKey)(publicKey);\n    return getSigningScheme(algorithm).verify((0, utils_1.hexToBytes)(messageHex), signature, publicKey);\n}\nexports.verify = verify;\nfunction computePublicKeyHash(publicKeyBytes) {\n    return (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKeyBytes));\n}\nfunction deriveAddressFromBytes(publicKeyBytes) {\n    return (0, ripple_address_codec_1.encodeAccountID)(computePublicKeyHash(publicKeyBytes));\n}\nfunction deriveAddress(publicKey) {\n    return deriveAddressFromBytes((0, utils_1.hexToBytes)(publicKey));\n}\nexports.deriveAddress = deriveAddress;\nfunction deriveNodeAddress(publicKey) {\n    const generatorBytes = (0, ripple_address_codec_1.decodeNodePublic)(publicKey);\n    const accountPublicBytes = (0, utils_2.accountPublicFromPublicGenerator)(generatorBytes);\n    return deriveAddressFromBytes(accountPublicBytes);\n}\nexports.deriveNodeAddress = deriveNodeAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcseUJBQXlCLEdBQUcscUJBQXFCLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0I7QUFDckosK0JBQStCLG1CQUFPLENBQUMseUZBQXNCO0FBQzdELDhDQUE2QyxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUNsSSxvQkFBb0IsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsaUdBQTBCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQywySEFBbUM7QUFDM0QsaUNBQWlDLG1CQUFPLENBQUMscUZBQWdCO0FBQ3pELGlDQUFpQyxtQkFBTyxDQUFDLHFGQUFnQjtBQUN6RCw4QkFBOEIsbUJBQU8sQ0FBQywrR0FBNkI7QUFDbkUsb0NBQW9DLG1CQUFPLENBQUMscUhBQTZCO0FBQ3pFLGtDQUFrQyxtQkFBTyxDQUFDLGlIQUEyQjtBQUNyRTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B2aW5kZXgvd2FsbGV0LWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvaW5kZXguanM/MDZmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZGVyaXZlTm9kZUFkZHJlc3MgPSBleHBvcnRzLmRlcml2ZUFkZHJlc3MgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnbiA9IGV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGV4cG9ydHMuZ2VuZXJhdGVTZWVkID0gdm9pZCAwO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlU2VlZDsgfSB9KTtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3JpcGVtZDE2MFwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vc2lnbmluZy1zY2hlbWVzL3NlY3AyNTZrMS91dGlsc1wiKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL1NoYTUxMlwiKSk7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9hc3NlcnRcIikpO1xuY29uc3QgZ2V0QWxnb3JpdGhtRnJvbUtleV8xID0gcmVxdWlyZShcIi4vdXRpbHMvZ2V0QWxnb3JpdGhtRnJvbUtleVwiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azFcIikpO1xuY29uc3QgZWQyNTUxOV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NpZ25pbmctc2NoZW1lcy9lZDI1NTE5XCIpKTtcbmZ1bmN0aW9uIGdldFNpZ25pbmdTY2hlbWUoYWxnb3JpdGhtKSB7XG4gICAgY29uc3Qgc2NoZW1lcyA9IHsgJ2VjZHNhLXNlY3AyNTZrMSc6IHNlY3AyNTZrMV8xLmRlZmF1bHQsIGVkMjU1MTk6IGVkMjU1MTlfMS5kZWZhdWx0IH07XG4gICAgcmV0dXJuIHNjaGVtZXNbYWxnb3JpdGhtXTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VlZChvcHRpb25zID0ge30pIHtcbiAgICBhc3NlcnRfMS5kZWZhdWx0Lm9rKCFvcHRpb25zLmVudHJvcHkgfHwgb3B0aW9ucy5lbnRyb3B5Lmxlbmd0aCA+PSAxNiwgJ2VudHJvcHkgdG9vIHNob3J0Jyk7XG4gICAgY29uc3QgZW50cm9weSA9IG9wdGlvbnMuZW50cm9weVxuICAgICAgICA/IG9wdGlvbnMuZW50cm9weS5zbGljZSgwLCAxNilcbiAgICAgICAgOiAoMCwgdXRpbHNfMS5yYW5kb21CeXRlcykoMTYpO1xuICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLmFsZ29yaXRobSA9PT0gJ2VkMjU1MTknID8gJ2VkMjU1MTknIDogJ3NlY3AyNTZrMSc7XG4gICAgcmV0dXJuICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmVuY29kZVNlZWQpKGVudHJvcHksIHR5cGUpO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVNlZWQgPSBnZW5lcmF0ZVNlZWQ7XG5mdW5jdGlvbiBkZXJpdmVLZXlwYWlyKHNlZWQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGVjb2RlZCA9ICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmRlY29kZVNlZWQpKHNlZWQpO1xuICAgIGNvbnN0IHByb3Bvc2VkQWxnb3JpdGhtID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFsZ29yaXRobSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVjb2RlZC50eXBlO1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IHByb3Bvc2VkQWxnb3JpdGhtID09PSAnZWQyNTUxOScgPyAnZWQyNTUxOScgOiAnZWNkc2Etc2VjcDI1NmsxJztcbiAgICBjb25zdCBzY2hlbWUgPSBnZXRTaWduaW5nU2NoZW1lKGFsZ29yaXRobSk7XG4gICAgY29uc3Qga2V5cGFpciA9IHNjaGVtZS5kZXJpdmVLZXlwYWlyKGRlY29kZWQuYnl0ZXMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1lc3NhZ2VUb1ZlcmlmeSA9IFNoYTUxMl8xLmRlZmF1bHQuaGFsZignVGhpcyB0ZXN0IG1lc3NhZ2Ugc2hvdWxkIHZlcmlmeS4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBzY2hlbWUuc2lnbihtZXNzYWdlVG9WZXJpZnksIGtleXBhaXIucHJpdmF0ZUtleSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFzY2hlbWUudmVyaWZ5KG1lc3NhZ2VUb1ZlcmlmeSwgc2lnbmF0dXJlLCBrZXlwYWlyLnB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXJpdmVkIGtleXBhaXIgZGlkIG5vdCBnZW5lcmF0ZSB2ZXJpZmlhYmxlIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cGFpcjtcbn1cbmV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGRlcml2ZUtleXBhaXI7XG5mdW5jdGlvbiBzaWduKG1lc3NhZ2VIZXgsIHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBhbGdvcml0aG0gPSAoMCwgZ2V0QWxnb3JpdGhtRnJvbUtleV8xLmdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5KShwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gZ2V0U2lnbmluZ1NjaGVtZShhbGdvcml0aG0pLnNpZ24oKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykobWVzc2FnZUhleCksIHByaXZhdGVLZXkpO1xufVxuZXhwb3J0cy5zaWduID0gc2lnbjtcbmZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlSGV4LCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGFsZ29yaXRobSA9ICgwLCBnZXRBbGdvcml0aG1Gcm9tS2V5XzEuZ2V0QWxnb3JpdGhtRnJvbVB1YmxpY0tleSkocHVibGljS2V5KTtcbiAgICByZXR1cm4gZ2V0U2lnbmluZ1NjaGVtZShhbGdvcml0aG0pLnZlcmlmeSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShtZXNzYWdlSGV4KSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpO1xufVxuZXhwb3J0cy52ZXJpZnkgPSB2ZXJpZnk7XG5mdW5jdGlvbiBjb21wdXRlUHVibGljS2V5SGFzaChwdWJsaWNLZXlCeXRlcykge1xuICAgIHJldHVybiAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKSgoMCwgc2hhMjU2XzEuc2hhMjU2KShwdWJsaWNLZXlCeXRlcykpO1xufVxuZnVuY3Rpb24gZGVyaXZlQWRkcmVzc0Zyb21CeXRlcyhwdWJsaWNLZXlCeXRlcykge1xuICAgIHJldHVybiAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5lbmNvZGVBY2NvdW50SUQpKGNvbXB1dGVQdWJsaWNLZXlIYXNoKHB1YmxpY0tleUJ5dGVzKSk7XG59XG5mdW5jdGlvbiBkZXJpdmVBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKCgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKHB1YmxpY0tleSkpO1xufVxuZXhwb3J0cy5kZXJpdmVBZGRyZXNzID0gZGVyaXZlQWRkcmVzcztcbmZ1bmN0aW9uIGRlcml2ZU5vZGVBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGdlbmVyYXRvckJ5dGVzID0gKDAsIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlTm9kZVB1YmxpYykocHVibGljS2V5KTtcbiAgICBjb25zdCBhY2NvdW50UHVibGljQnl0ZXMgPSAoMCwgdXRpbHNfMi5hY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvcikoZ2VuZXJhdG9yQnl0ZXMpO1xuICAgIHJldHVybiBkZXJpdmVBZGRyZXNzRnJvbUJ5dGVzKGFjY291bnRQdWJsaWNCeXRlcyk7XG59XG5leHBvcnRzLmRlcml2ZU5vZGVBZGRyZXNzID0gZGVyaXZlTm9kZUFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ed25519_1 = __webpack_require__(/*! @noble/curves/ed25519 */ \"(ssr)/../../node_modules/@noble/curves/ed25519.js\");\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! ../../utils/assert */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst ED_PREFIX = 'ED';\nconst ed25519 = {\n    deriveKeypair(entropy) {\n        const rawPrivateKey = Sha512_1.default.half(entropy);\n        const privateKey = ED_PREFIX + (0, utils_1.bytesToHex)(rawPrivateKey);\n        const publicKey = ED_PREFIX + (0, utils_1.bytesToHex)(ed25519_1.ed25519.getPublicKey(rawPrivateKey));\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        assert_1.default.ok(message instanceof Uint8Array, 'message must be array of octets');\n        assert_1.default.ok(privateKey.length === 66, 'private key must be 33 bytes including prefix');\n        return (0, utils_1.bytesToHex)(ed25519_1.ed25519.sign(message, privateKey.slice(2)));\n    },\n    verify(message, signature, publicKey) {\n        // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey\n        assert_1.default.ok(publicKey.length === 66, 'public key must be 33 bytes including prefix');\n        return ed25519_1.ed25519.verify(signature, message, \n        // Remove the 0xED prefix\n        publicKey.slice(2), \n        // By default, set zip215 to false for compatibility reasons.\n        // ZIP 215 is a stricter Ed25519 signature verification scheme.\n        // However, setting it to false adheres to the more commonly used\n        // RFC8032 / NIST186-5 standards, making it compatible with systems\n        // like the XRP Ledger.\n        { zip215: false });\n    },\n};\nexports[\"default\"] = ed25519;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3NpZ25pbmctc2NoZW1lcy9lZDI1NTE5L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMsZ0ZBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNqRCxpQ0FBaUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMseUZBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHZpbmRleC93YWxsZXQtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC9zaWduaW5nLXNjaGVtZXMvZWQyNTUxOS9pbmRleC5qcz85NzRkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZWQyNTUxOV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvZWQyNTUxOVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXNzZXJ0XCIpKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgRURfUFJFRklYID0gJ0VEJztcbmNvbnN0IGVkMjU1MTkgPSB7XG4gICAgZGVyaXZlS2V5cGFpcihlbnRyb3B5KSB7XG4gICAgICAgIGNvbnN0IHJhd1ByaXZhdGVLZXkgPSBTaGE1MTJfMS5kZWZhdWx0LmhhbGYoZW50cm9weSk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBFRF9QUkVGSVggKyAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KShyYXdQcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gRURfUFJFRklYICsgKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkoZWQyNTUxOV8xLmVkMjU1MTkuZ2V0UHVibGljS2V5KHJhd1ByaXZhdGVLZXkpKTtcbiAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH07XG4gICAgfSxcbiAgICBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vayhtZXNzYWdlIGluc3RhbmNlb2YgVWludDhBcnJheSwgJ21lc3NhZ2UgbXVzdCBiZSBhcnJheSBvZiBvY3RldHMnKTtcbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vayhwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjYsICdwcml2YXRlIGtleSBtdXN0IGJlIDMzIGJ5dGVzIGluY2x1ZGluZyBwcmVmaXgnKTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGVkMjU1MTlfMS5lZDI1NTE5LnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleS5zbGljZSgyKSkpO1xuICAgIH0sXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICAgIC8vIFVubGlrZWx5IHRvIGJlIHRyaWdnZXJlZCBhcyB0aGVzZSBhcmUgaW50ZXJuYWwgYW5kIGd1YXJkZWQgYnkgZ2V0QWxnb3JpdGhtRnJvbUtleVxuICAgICAgICBhc3NlcnRfMS5kZWZhdWx0Lm9rKHB1YmxpY0tleS5sZW5ndGggPT09IDY2LCAncHVibGljIGtleSBtdXN0IGJlIDMzIGJ5dGVzIGluY2x1ZGluZyBwcmVmaXgnKTtcbiAgICAgICAgcmV0dXJuIGVkMjU1MTlfMS5lZDI1NTE5LnZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIFxuICAgICAgICAvLyBSZW1vdmUgdGhlIDB4RUQgcHJlZml4XG4gICAgICAgIHB1YmxpY0tleS5zbGljZSgyKSwgXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHNldCB6aXAyMTUgdG8gZmFsc2UgZm9yIGNvbXBhdGliaWxpdHkgcmVhc29ucy5cbiAgICAgICAgLy8gWklQIDIxNSBpcyBhIHN0cmljdGVyIEVkMjU1MTkgc2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBzY2hlbWUuXG4gICAgICAgIC8vIEhvd2V2ZXIsIHNldHRpbmcgaXQgdG8gZmFsc2UgYWRoZXJlcyB0byB0aGUgbW9yZSBjb21tb25seSB1c2VkXG4gICAgICAgIC8vIFJGQzgwMzIgLyBOSVNUMTg2LTUgc3RhbmRhcmRzLCBtYWtpbmcgaXQgY29tcGF0aWJsZSB3aXRoIHN5c3RlbXNcbiAgICAgICAgLy8gbGlrZSB0aGUgWFJQIExlZGdlci5cbiAgICAgICAgeyB6aXAyMTU6IGZhbHNlIH0pO1xuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZWQyNTUxOTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/ed25519/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/@noble/curves/abstract/utils.js\");\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../../node_modules/@noble/curves/secp256k1.js\");\nconst utils_2 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst utils_3 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\");\nconst assert_1 = __importDefault(__webpack_require__(/*! ../../utils/assert */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/assert.js\"));\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst SECP256K1_PREFIX = '00';\nconst secp256k1 = {\n    deriveKeypair(entropy, options) {\n        const derived = (0, utils_3.derivePrivateKey)(entropy, options);\n        const privateKey = SECP256K1_PREFIX + (0, utils_2.bytesToHex)((0, utils_1.numberToBytesBE)(derived, 32));\n        const publicKey = (0, utils_2.bytesToHex)(secp256k1_1.secp256k1.getPublicKey(derived, true));\n        return { privateKey, publicKey };\n    },\n    sign(message, privateKey) {\n        // Some callers pass the privateKey with the prefix, others without.\n        // @noble/curves will throw if the key is not exactly 32 bytes, so we\n        // normalize it before passing to the sign method.\n        assert_1.default.ok((privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||\n            privateKey.length === 64);\n        const normedPrivateKey = privateKey.length === 66 ? privateKey.slice(2) : privateKey;\n        return secp256k1_1.secp256k1\n            .sign(Sha512_1.default.half(message), normedPrivateKey, {\n            // \"Canonical\" signatures\n            lowS: true,\n            // Would fail tests if signatures aren't deterministic\n            extraEntropy: undefined,\n        })\n            .toDERHex(true)\n            .toUpperCase();\n    },\n    verify(message, signature, publicKey) {\n        const decoded = secp256k1_1.secp256k1.Signature.fromDER(signature);\n        return secp256k1_1.secp256k1.verify(decoded, Sha512_1.default.half(message), publicKey);\n    },\n};\nexports[\"default\"] = secp256k1;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azEvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyw4RkFBOEI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQXlCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLCtGQUF5QjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyxpR0FBUztBQUNqQyxpQ0FBaUMsbUJBQU8sQ0FBQyx5RkFBb0I7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMseUZBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHZpbmRleC93YWxsZXQtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC9zaWduaW5nLXNjaGVtZXMvc2VjcDI1NmsxL2luZGV4LmpzP2UxNTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHNcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvdXRpbHNcIik7XG5jb25zdCB1dGlsc18zID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBhc3NlcnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXNzZXJ0XCIpKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgU0VDUDI1NksxX1BSRUZJWCA9ICcwMCc7XG5jb25zdCBzZWNwMjU2azEgPSB7XG4gICAgZGVyaXZlS2V5cGFpcihlbnRyb3B5LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWQgPSAoMCwgdXRpbHNfMy5kZXJpdmVQcml2YXRlS2V5KShlbnRyb3B5LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IFNFQ1AyNTZLMV9QUkVGSVggKyAoMCwgdXRpbHNfMi5ieXRlc1RvSGV4KSgoMCwgdXRpbHNfMS5udW1iZXJUb0J5dGVzQkUpKGRlcml2ZWQsIDMyKSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18yLmJ5dGVzVG9IZXgpKHNlY3AyNTZrMV8xLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoZGVyaXZlZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm4geyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfTtcbiAgICB9LFxuICAgIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSkge1xuICAgICAgICAvLyBTb21lIGNhbGxlcnMgcGFzcyB0aGUgcHJpdmF0ZUtleSB3aXRoIHRoZSBwcmVmaXgsIG90aGVycyB3aXRob3V0LlxuICAgICAgICAvLyBAbm9ibGUvY3VydmVzIHdpbGwgdGhyb3cgaWYgdGhlIGtleSBpcyBub3QgZXhhY3RseSAzMiBieXRlcywgc28gd2VcbiAgICAgICAgLy8gbm9ybWFsaXplIGl0IGJlZm9yZSBwYXNzaW5nIHRvIHRoZSBzaWduIG1ldGhvZC5cbiAgICAgICAgYXNzZXJ0XzEuZGVmYXVsdC5vaygocHJpdmF0ZUtleS5sZW5ndGggPT09IDY2ICYmIHByaXZhdGVLZXkuc3RhcnRzV2l0aChTRUNQMjU2SzFfUFJFRklYKSkgfHxcbiAgICAgICAgICAgIHByaXZhdGVLZXkubGVuZ3RoID09PSA2NCk7XG4gICAgICAgIGNvbnN0IG5vcm1lZFByaXZhdGVLZXkgPSBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjYgPyBwcml2YXRlS2V5LnNsaWNlKDIpIDogcHJpdmF0ZUtleTtcbiAgICAgICAgcmV0dXJuIHNlY3AyNTZrMV8xLnNlY3AyNTZrMVxuICAgICAgICAgICAgLnNpZ24oU2hhNTEyXzEuZGVmYXVsdC5oYWxmKG1lc3NhZ2UpLCBub3JtZWRQcml2YXRlS2V5LCB7XG4gICAgICAgICAgICAvLyBcIkNhbm9uaWNhbFwiIHNpZ25hdHVyZXNcbiAgICAgICAgICAgIGxvd1M6IHRydWUsXG4gICAgICAgICAgICAvLyBXb3VsZCBmYWlsIHRlc3RzIGlmIHNpZ25hdHVyZXMgYXJlbid0IGRldGVybWluaXN0aWNcbiAgICAgICAgICAgIGV4dHJhRW50cm9weTogdW5kZWZpbmVkLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRvREVSSGV4KHRydWUpXG4gICAgICAgICAgICAudG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tREVSKHNpZ25hdHVyZSk7XG4gICAgICAgIHJldHVybiBzZWNwMjU2azFfMS5zZWNwMjU2azEudmVyaWZ5KGRlY29kZWQsIFNoYTUxMl8xLmRlZmF1bHQuaGFsZihtZXNzYWdlKSwgcHVibGljS2V5KTtcbiAgICB9LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHNlY3AyNTZrMTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;\nconst secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/../../node_modules/@noble/curves/secp256k1.js\");\nconst Sha512_1 = __importDefault(__webpack_require__(/*! ../../utils/Sha512 */ \"(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js\"));\nconst ZERO = BigInt(0);\nfunction deriveScalar(bytes, discrim) {\n    const order = secp256k1_1.secp256k1.CURVE.n;\n    for (let i = 0; i <= 4294967295; i++) {\n        // We hash the bytes to find a 256-bit number, looping until we are sure it\n        // is less than the order of the curve.\n        const hasher = new Sha512_1.default().add(bytes);\n        // If the optional discriminator index was passed in, update the hash.\n        if (discrim !== undefined) {\n            hasher.addU32(discrim);\n        }\n        hasher.addU32(i);\n        const key = hasher.first256BigInt();\n        /* istanbul ignore else */\n        if (key > ZERO && key < order) {\n            return key;\n        }\n    }\n    // This error is practically impossible to reach.\n    // The order of the curve describes the (finite) amount of points on the curve\n    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n    // How often will an (essentially) random number generated by Sha512 be larger than that?\n    // There's 2^32 chances (the for loop) to get a number smaller than the order,\n    // and it's rare that you'll even get past the first loop iteration.\n    // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n    //\n    /* istanbul ignore next */\n    throw new Error('impossible unicorn ;)');\n}\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nfunction derivePrivateKey(seed, opts = {}) {\n    const root = opts.validator;\n    const order = secp256k1_1.secp256k1.CURVE.n;\n    // This private generator represents the `root` private key, and is what's\n    // used by validators for signing when a keypair is generated from a seed.\n    const privateGen = deriveScalar(seed);\n    if (root) {\n        // As returned by validation_create for a given seed\n        return privateGen;\n    }\n    const publicGen = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true);\n    // A seed can generate many keypairs as a function of the seed and a uint32.\n    // Almost everyone just uses the first account, `0`.\n    const accountIndex = opts.accountIndex || 0;\n    return (deriveScalar(publicGen, accountIndex) + privateGen) % order;\n}\nexports.derivePrivateKey = derivePrivateKey;\nfunction accountPublicFromPublicGenerator(publicGenBytes) {\n    const rootPubPoint = secp256k1_1.secp256k1.ProjectivePoint.fromHex(publicGenBytes);\n    const scalar = deriveScalar(publicGenBytes, 0);\n    const point = secp256k1_1.secp256k1.ProjectivePoint.BASE.multiply(scalar);\n    const offset = rootPubPoint.add(point);\n    return offset.toRawBytes(true);\n}\nexports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azEvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3Q0FBd0MsR0FBRyx3QkFBd0I7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQXlCO0FBQ3JELGlDQUFpQyxtQkFBTyxDQUFDLHlGQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdmluZGV4L3dhbGxldC1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3NpZ25pbmctc2NoZW1lcy9zZWNwMjU2azEvdXRpbHMuanM/Yjc0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IgPSBleHBvcnRzLmRlcml2ZVByaXZhdGVLZXkgPSB2b2lkIDA7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IFNoYTUxMl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi91dGlscy9TaGE1MTJcIikpO1xuY29uc3QgWkVSTyA9IEJpZ0ludCgwKTtcbmZ1bmN0aW9uIGRlcml2ZVNjYWxhcihieXRlcywgZGlzY3JpbSkge1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gNDI5NDk2NzI5NTsgaSsrKSB7XG4gICAgICAgIC8vIFdlIGhhc2ggdGhlIGJ5dGVzIHRvIGZpbmQgYSAyNTYtYml0IG51bWJlciwgbG9vcGluZyB1bnRpbCB3ZSBhcmUgc3VyZSBpdFxuICAgICAgICAvLyBpcyBsZXNzIHRoYW4gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZS5cbiAgICAgICAgY29uc3QgaGFzaGVyID0gbmV3IFNoYTUxMl8xLmRlZmF1bHQoKS5hZGQoYnl0ZXMpO1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9uYWwgZGlzY3JpbWluYXRvciBpbmRleCB3YXMgcGFzc2VkIGluLCB1cGRhdGUgdGhlIGhhc2guXG4gICAgICAgIGlmIChkaXNjcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc2hlci5hZGRVMzIoZGlzY3JpbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaGVyLmFkZFUzMihpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaGVyLmZpcnN0MjU2QmlnSW50KCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChrZXkgPiBaRVJPICYmIGtleSA8IG9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRoaXMgZXJyb3IgaXMgcHJhY3RpY2FsbHkgaW1wb3NzaWJsZSB0byByZWFjaC5cbiAgICAvLyBUaGUgb3JkZXIgb2YgdGhlIGN1cnZlIGRlc2NyaWJlcyB0aGUgKGZpbml0ZSkgYW1vdW50IG9mIHBvaW50cyBvbiB0aGUgY3VydmVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9lbGxpcHRpYy9ibG9iL21hc3Rlci9saWIvZWxsaXB0aWMvY3VydmVzLmpzI0wxODJcbiAgICAvLyBIb3cgb2Z0ZW4gd2lsbCBhbiAoZXNzZW50aWFsbHkpIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGVkIGJ5IFNoYTUxMiBiZSBsYXJnZXIgdGhhbiB0aGF0P1xuICAgIC8vIFRoZXJlJ3MgMl4zMiBjaGFuY2VzICh0aGUgZm9yIGxvb3ApIHRvIGdldCBhIG51bWJlciBzbWFsbGVyIHRoYW4gdGhlIG9yZGVyLFxuICAgIC8vIGFuZCBpdCdzIHJhcmUgdGhhdCB5b3UnbGwgZXZlbiBnZXQgcGFzdCB0aGUgZmlyc3QgbG9vcCBpdGVyYXRpb24uXG4gICAgLy8gTm90ZSB0aGF0IGluIFR5cGVTY3JpcHQgd2UgYWN0dWFsbHkgbmVlZCB0aGUgdGhyb3csIG90aGVyd2lzZSB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHdvdWxkIGJlIGJpZ2ludCB8IHVuZGVmaW5lZFxuICAgIC8vXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ltcG9zc2libGUgdW5pY29ybiA7KScpO1xufVxuLyoqXG4gKiBAcGFyYW0gc2VlZCAtIEJ5dGVzLlxuICogQHBhcmFtIFtvcHRzXSAtIE9iamVjdC5cbiAqIEBwYXJhbSBbb3B0cy5hY2NvdW50SW5kZXg9MF0gLSBUaGUgYWNjb3VudCBudW1iZXIgdG8gZ2VuZXJhdGUuXG4gKiBAcGFyYW0gW29wdHMudmFsaWRhdG9yPWZhbHNlXSAtIEdlbmVyYXRlIHJvb3Qga2V5LXBhaXIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcyB1c2VkIGJ5IHZhbGlkYXRvcnMuXG4gKiBAcmV0dXJucyB7YmlnaW50fSAyNTYgYml0IHNjYWxhciB2YWx1ZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVByaXZhdGVLZXkoc2VlZCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdCA9IG9wdHMudmFsaWRhdG9yO1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLkNVUlZFLm47XG4gICAgLy8gVGhpcyBwcml2YXRlIGdlbmVyYXRvciByZXByZXNlbnRzIHRoZSBgcm9vdGAgcHJpdmF0ZSBrZXksIGFuZCBpcyB3aGF0J3NcbiAgICAvLyB1c2VkIGJ5IHZhbGlkYXRvcnMgZm9yIHNpZ25pbmcgd2hlbiBhIGtleXBhaXIgaXMgZ2VuZXJhdGVkIGZyb20gYSBzZWVkLlxuICAgIGNvbnN0IHByaXZhdGVHZW4gPSBkZXJpdmVTY2FsYXIoc2VlZCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgLy8gQXMgcmV0dXJuZWQgYnkgdmFsaWRhdGlvbl9jcmVhdGUgZm9yIGEgZ2l2ZW4gc2VlZFxuICAgICAgICByZXR1cm4gcHJpdmF0ZUdlbjtcbiAgICB9XG4gICAgY29uc3QgcHVibGljR2VuID0gc2VjcDI1NmsxXzEuc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludC5CQVNFLm11bHRpcGx5KHByaXZhdGVHZW4pLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgLy8gQSBzZWVkIGNhbiBnZW5lcmF0ZSBtYW55IGtleXBhaXJzIGFzIGEgZnVuY3Rpb24gb2YgdGhlIHNlZWQgYW5kIGEgdWludDMyLlxuICAgIC8vIEFsbW9zdCBldmVyeW9uZSBqdXN0IHVzZXMgdGhlIGZpcnN0IGFjY291bnQsIGAwYC5cbiAgICBjb25zdCBhY2NvdW50SW5kZXggPSBvcHRzLmFjY291bnRJbmRleCB8fCAwO1xuICAgIHJldHVybiAoZGVyaXZlU2NhbGFyKHB1YmxpY0dlbiwgYWNjb3VudEluZGV4KSArIHByaXZhdGVHZW4pICUgb3JkZXI7XG59XG5leHBvcnRzLmRlcml2ZVByaXZhdGVLZXkgPSBkZXJpdmVQcml2YXRlS2V5O1xuZnVuY3Rpb24gYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IocHVibGljR2VuQnl0ZXMpIHtcbiAgICBjb25zdCByb290UHViUG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LmZyb21IZXgocHVibGljR2VuQnl0ZXMpO1xuICAgIGNvbnN0IHNjYWxhciA9IGRlcml2ZVNjYWxhcihwdWJsaWNHZW5CeXRlcywgMCk7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5zZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LkJBU0UubXVsdGlwbHkoc2NhbGFyKTtcbiAgICBjb25zdCBvZmZzZXQgPSByb290UHViUG9pbnQuYWRkKHBvaW50KTtcbiAgICByZXR1cm4gb2Zmc2V0LnRvUmF3Qnl0ZXModHJ1ZSk7XG59XG5leHBvcnRzLmFjY291bnRQdWJsaWNGcm9tUHVibGljR2VuZXJhdG9yID0gYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/signing-schemes/secp256k1/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/utils/Sha512.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sha512_1 = __webpack_require__(/*! @xrplf/isomorphic/sha512 */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/sha512/index.js\");\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/@noble/curves/abstract/utils.js\");\nclass Sha512 {\n    constructor() {\n        // instantiate empty sha512 hash\n        this.hash = sha512_1.sha512.create();\n    }\n    static half(input) {\n        return new Sha512().add(input).first256();\n    }\n    add(bytes) {\n        this.hash.update(bytes);\n        return this;\n    }\n    addU32(i) {\n        const buffer = new Uint8Array(4);\n        new DataView(buffer.buffer).setUint32(0, i);\n        return this.add(buffer);\n    }\n    finish() {\n        return this.hash.digest();\n    }\n    first256() {\n        return this.finish().slice(0, 32);\n    }\n    first256BigInt() {\n        return (0, utils_1.bytesToNumberBE)(this.first256());\n    }\n}\nexports[\"default\"] = Sha512;\n//# sourceMappingURL=Sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzL1NoYTUxMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxpR0FBMEI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsOEZBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdmluZGV4L3dhbGxldC1hcHAvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzL1NoYTUxMi5qcz8wY2E1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQHhycGxmL2lzb21vcnBoaWMvc2hhNTEyXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzXCIpO1xuY2xhc3MgU2hhNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gaW5zdGFudGlhdGUgZW1wdHkgc2hhNTEyIGhhc2hcbiAgICAgICAgdGhpcy5oYXNoID0gc2hhNTEyXzEuc2hhNTEyLmNyZWF0ZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgaGFsZihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNoYTUxMigpLmFkZChpbnB1dCkuZmlyc3QyNTYoKTtcbiAgICB9XG4gICAgYWRkKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuaGFzaC51cGRhdGUoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkVTMyKGkpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICAgIG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyKS5zZXRVaW50MzIoMCwgaSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChidWZmZXIpO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIGZpcnN0MjU2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKS5zbGljZSgwLCAzMik7XG4gICAgfVxuICAgIGZpcnN0MjU2QmlnSW50KCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb051bWJlckJFKSh0aGlzLmZpcnN0MjU2KCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNoYTUxMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNoYTUxMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/utils/Sha512.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/utils/assert.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/utils/assert.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst assertHelper = {\n    ok(cond, message) {\n        if (!cond) {\n            throw new Error(message);\n        }\n    },\n};\nexports[\"default\"] = assertHelper;\n//# sourceMappingURL=assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzL2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL0B2aW5kZXgvd2FsbGV0LWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvdXRpbHMvYXNzZXJ0LmpzP2U1NmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnRIZWxwZXIgPSB7XG4gICAgb2soY29uZCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0SGVscGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/utils/assert.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAlgorithmFromPrivateKey = exports.getAlgorithmFromPublicKey = exports.getAlgorithmFromKey = void 0;\nvar Prefix;\n(function (Prefix) {\n    Prefix[Prefix[\"NONE\"] = -1] = \"NONE\";\n    Prefix[Prefix[\"ED25519\"] = 237] = \"ED25519\";\n    Prefix[Prefix[\"SECP256K1_PUB_X\"] = 2] = \"SECP256K1_PUB_X\";\n    Prefix[Prefix[\"SECP256K1_PUB_X_ODD_Y\"] = 3] = \"SECP256K1_PUB_X_ODD_Y\";\n    Prefix[Prefix[\"SECP256K1_PUB_XY\"] = 4] = \"SECP256K1_PUB_XY\";\n    Prefix[Prefix[\"SECP256K1_PRIVATE\"] = 0] = \"SECP256K1_PRIVATE\";\n})(Prefix || (Prefix = {}));\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES = {\n    [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n    [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n    [`private_${Prefix.ED25519}_33`]: 'ed25519',\n    [`public_${Prefix.ED25519}_33`]: 'ed25519',\n    [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n    [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n    [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',\n};\nfunction getKeyInfo(key) {\n    return {\n        prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n        len: key.length / 2,\n    };\n}\nfunction prefixRepr(prefix) {\n    return prefix === Prefix.NONE\n        ? 'None'\n        : `0x${prefix.toString(16).padStart(2, '0')}`;\n}\nfunction getValidFormatsTable(type) {\n    // No need overkill with renderTable method\n    const padding = 2;\n    const colWidth = {\n        algorithm: 'ecdsa-secp256k1'.length + padding,\n        prefix: '0x00'.length + padding,\n    };\n    return Object.entries(KEY_TYPES)\n        .filter(([key]) => key.startsWith(type))\n        .map(([key, algorithm]) => {\n        const [, prefix, length] = key.split('_');\n        const paddedAlgo = algorithm.padEnd(colWidth.algorithm);\n        const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix);\n        return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`;\n    })\n        .join('\\n');\n}\nfunction keyError({ key, type, prefix, len, }) {\n    const validFormats = getValidFormatsTable(type);\n    return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`;\n}\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nfunction getAlgorithmFromKey(key, type) {\n    const { prefix, len } = getKeyInfo(key);\n    // Special case back compat support for no prefix\n    const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix;\n    const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`];\n    if (!algorithm) {\n        throw new Error(keyError({ key, type, len, prefix: usedPrefix }));\n    }\n    return algorithm;\n}\nexports.getAlgorithmFromKey = getAlgorithmFromKey;\nfunction getAlgorithmFromPublicKey(key) {\n    return getAlgorithmFromKey(key, 'public');\n}\nexports.getAlgorithmFromPublicKey = getAlgorithmFromPublicKey;\nfunction getAlgorithmFromPrivateKey(key) {\n    return getAlgorithmFromKey(key, 'private');\n}\nexports.getAlgorithmFromPrivateKey = getAlgorithmFromPrivateKey;\n//# sourceMappingURL=getAlgorithmFromKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzL2dldEFsZ29yaXRobUZyb21LZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsaUNBQWlDLEdBQUcsMkJBQTJCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QixnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQixlQUFlO0FBQy9CLGVBQWUsZUFBZTtBQUM5QixlQUFlLHVCQUF1QjtBQUN0QyxlQUFlLDZCQUE2QjtBQUM1QyxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxZQUFZLGNBQWMsVUFBVSxRQUFRO0FBQzFFLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBOztBQUVBLFFBQVE7QUFDUixPQUFPO0FBQ1AsVUFBVTtBQUNWLFVBQVUsS0FBSzs7QUFFZixhQUFhLE1BQU07QUFDbkIsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLEdBQUcsV0FBVyxHQUFHLElBQUk7QUFDN0Q7QUFDQSxtQ0FBbUMsb0NBQW9DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHZpbmRleC93YWxsZXQtYXBwLy4uLy4uL25vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC91dGlscy9nZXRBbGdvcml0aG1Gcm9tS2V5LmpzP2M2ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5ID0gZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5ID0gZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tS2V5ID0gdm9pZCAwO1xudmFyIFByZWZpeDtcbihmdW5jdGlvbiAoUHJlZml4KSB7XG4gICAgUHJlZml4W1ByZWZpeFtcIk5PTkVcIl0gPSAtMV0gPSBcIk5PTkVcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiRUQyNTUxOVwiXSA9IDIzN10gPSBcIkVEMjU1MTlcIjtcbiAgICBQcmVmaXhbUHJlZml4W1wiU0VDUDI1NksxX1BVQl9YXCJdID0gMl0gPSBcIlNFQ1AyNTZLMV9QVUJfWFwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJTRUNQMjU2SzFfUFVCX1hfT0REX1lcIl0gPSAzXSA9IFwiU0VDUDI1NksxX1BVQl9YX09ERF9ZXCI7XG4gICAgUHJlZml4W1ByZWZpeFtcIlNFQ1AyNTZLMV9QVUJfWFlcIl0gPSA0XSA9IFwiU0VDUDI1NksxX1BVQl9YWVwiO1xuICAgIFByZWZpeFtQcmVmaXhbXCJTRUNQMjU2SzFfUFJJVkFURVwiXSA9IDBdID0gXCJTRUNQMjU2SzFfUFJJVkFURVwiO1xufSkoUHJlZml4IHx8IChQcmVmaXggPSB7fSkpO1xuLyoqXG4gKiB8IEN1cnZlICAgICB8IFR5cGUgICAgICAgIHwgUHJlZml4IHwgTGVuZ3RoIHwgRGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBBbGdvcml0aG0gICAgICAgfFxuICogfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18Oi0tLS0tLTp8Oi0tLS0tLTp8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tOnxcbiAqIHwgZWQyNTUxOSAgIHwgUHJpdmF0ZSAgICAgfCAgMHhFRCAgfCAgIDMzICAgfCBwcmVmaXggKyBVaW50MjU2TEUgKDAgPCBuIDwgb3JkZXIgKSAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgZWQyNTUxOSB8XG4gKiB8IGVkMjU1MTkgICB8IFB1YmxpYyAgICAgIHwgIDB4RUQgIHwgICAzMyAgIHwgcHJlZml4ICsgMzIgeS1ieXRlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgIGVkMjU1MTkgfFxuICogfCBzZWNwMjU2azEgfCBQdWJsaWMgKDEpICB8ICAweDAyICB8ICAgMzMgICB8IHByZWZpeCArIDMyIHgtYnl0ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWNkc2Etc2VjcDI1NmsxIHxcbiAqIHwgc2VjcDI1NmsxIHwgUHVibGljICgyKSAgfCAgMHgwMyAgfCAgIDMzICAgfCBwcmVmaXggKyAzMiB4LWJ5dGVzICh5IGlzIG9kZCkgICAgICAgICAgICAgICAgICAgICAgICB8IGVjZHNhLXNlY3AyNTZrMSB8XG4gKiB8IHNlY3AyNTZrMSB8IFB1YmxpYyAoMykgIHwgIDB4MDQgIHwgICA2NSAgIHwgcHJlZml4ICsgMzIgeC1ieXRlcyArIDMyIHktYnl0ZXMgICAgICAgICAgICAgICAgICAgICAgfCBlY2RzYS1zZWNwMjU2azEgfFxuICogfCBzZWNwMjU2azEgfCBQcml2YXRlICgxKSB8ICBOb25lICB8ICAgMzIgICB8IFVpbnQyNTZCRSAoMCA8IG4gPCBvcmRlcikgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZWNkc2Etc2VjcDI1NmsxIHxcbiAqIHwgc2VjcDI1NmsxIHwgUHJpdmF0ZSAoMikgfCAgMHgwMCAgfCAgIDMzICAgfCBwcmVmaXggKyBVaW50MjU2QkUgKDAgPCBuIDwgb3JkZXIpICAgICAgICAgICAgICAgICAgICB8IGVjZHNhLXNlY3AyNTZrMSB8XG4gKlxuICogTm90ZTogVGhlIDB4MDAgcHJlZml4IGZvciBzZWNwazI1NmsxIFByaXZhdGUgKDIpIGVzc2VudGlhbGx5IDAgcGFkcyB0aGUgbnVtYmVyXG4gKiAgICAgICBhbmQgdGhlIGludGVycHJldGVkIG51bWJlciBpcyB0aGUgc2FtZSBhcyAzMiBieXRlcy5cbiAqL1xuY29uc3QgS0VZX1RZUEVTID0ge1xuICAgIFtgcHJpdmF0ZV8ke1ByZWZpeC5OT05FfV8zMmBdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbiAgICBbYHByaXZhdGVfJHtQcmVmaXguU0VDUDI1NksxX1BSSVZBVEV9XzMzYF06ICdlY2RzYS1zZWNwMjU2azEnLFxuICAgIFtgcHJpdmF0ZV8ke1ByZWZpeC5FRDI1NTE5fV8zM2BdOiAnZWQyNTUxOScsXG4gICAgW2BwdWJsaWNfJHtQcmVmaXguRUQyNTUxOX1fMzNgXTogJ2VkMjU1MTknLFxuICAgIFtgcHVibGljXyR7UHJlZml4LlNFQ1AyNTZLMV9QVUJfWH1fMzNgXTogJ2VjZHNhLXNlY3AyNTZrMScsXG4gICAgW2BwdWJsaWNfJHtQcmVmaXguU0VDUDI1NksxX1BVQl9YX09ERF9ZfV8zM2BdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbiAgICBbYHB1YmxpY18ke1ByZWZpeC5TRUNQMjU2SzFfUFVCX1hZfV82NWBdOiAnZWNkc2Etc2VjcDI1NmsxJyxcbn07XG5mdW5jdGlvbiBnZXRLZXlJbmZvKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDoga2V5Lmxlbmd0aCA8IDIgPyBQcmVmaXguTk9ORSA6IHBhcnNlSW50KGtleS5zbGljZSgwLCAyKSwgMTYpLFxuICAgICAgICBsZW46IGtleS5sZW5ndGggLyAyLFxuICAgIH07XG59XG5mdW5jdGlvbiBwcmVmaXhSZXByKHByZWZpeCkge1xuICAgIHJldHVybiBwcmVmaXggPT09IFByZWZpeC5OT05FXG4gICAgICAgID8gJ05vbmUnXG4gICAgICAgIDogYDB4JHtwcmVmaXgudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9YDtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkRm9ybWF0c1RhYmxlKHR5cGUpIHtcbiAgICAvLyBObyBuZWVkIG92ZXJraWxsIHdpdGggcmVuZGVyVGFibGUgbWV0aG9kXG4gICAgY29uc3QgcGFkZGluZyA9IDI7XG4gICAgY29uc3QgY29sV2lkdGggPSB7XG4gICAgICAgIGFsZ29yaXRobTogJ2VjZHNhLXNlY3AyNTZrMScubGVuZ3RoICsgcGFkZGluZyxcbiAgICAgICAgcHJlZml4OiAnMHgwMCcubGVuZ3RoICsgcGFkZGluZyxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhLRVlfVFlQRVMpXG4gICAgICAgIC5maWx0ZXIoKFtrZXldKSA9PiBrZXkuc3RhcnRzV2l0aCh0eXBlKSlcbiAgICAgICAgLm1hcCgoW2tleSwgYWxnb3JpdGhtXSkgPT4ge1xuICAgICAgICBjb25zdCBbLCBwcmVmaXgsIGxlbmd0aF0gPSBrZXkuc3BsaXQoJ18nKTtcbiAgICAgICAgY29uc3QgcGFkZGVkQWxnbyA9IGFsZ29yaXRobS5wYWRFbmQoY29sV2lkdGguYWxnb3JpdGhtKTtcbiAgICAgICAgY29uc3QgcGFkZGVkUHJlZml4ID0gcHJlZml4UmVwcihOdW1iZXIocHJlZml4KSkucGFkRW5kKGNvbFdpZHRoLnByZWZpeCk7XG4gICAgICAgIHJldHVybiBgJHtwYWRkZWRBbGdvfSAtIFByZWZpeDogJHtwYWRkZWRQcmVmaXh9IExlbmd0aDogJHtsZW5ndGh9IGJ5dGVzYDtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBrZXlFcnJvcih7IGtleSwgdHlwZSwgcHJlZml4LCBsZW4sIH0pIHtcbiAgICBjb25zdCB2YWxpZEZvcm1hdHMgPSBnZXRWYWxpZEZvcm1hdHNUYWJsZSh0eXBlKTtcbiAgICByZXR1cm4gYGludmFsaWRfa2V5OlxuXG5UeXBlOiAke3R5cGV9XG5LZXk6ICR7a2V5fVxuUHJlZml4OiAke3ByZWZpeFJlcHIocHJlZml4KX0gXG5MZW5ndGg6ICR7bGVufSBieXRlc1xuXG5BY2NlcHRhYmxlICR7dHlwZX0gZm9ybWF0cyBhcmU6XG4ke3ZhbGlkRm9ybWF0c31cbmA7XG59XG4vKipcbiAqIERldGVybWluZXMgdGhlIGFsZ29yaXRobSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBrZXkgKHB1YmxpYy9wcml2YXRlKS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBrZXkuXG4gKiBAcGFyYW0gdHlwZSAtIHdoZXRoZXIgZXhwZWN0ZWQga2V5IGlzIHB1YmxpYyBvciBwcml2YXRlXG4gKiBAcmV0dXJucyBBbGdvcml0aG0gYWxnb3JpdGhtIGZvciBzaWduaW5nL3ZlcmlmeWluZ1xuICogQHRocm93cyBFcnJvciB3aGVuIGtleSBpcyBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIGdldEFsZ29yaXRobUZyb21LZXkoa2V5LCB0eXBlKSB7XG4gICAgY29uc3QgeyBwcmVmaXgsIGxlbiB9ID0gZ2V0S2V5SW5mbyhrZXkpO1xuICAgIC8vIFNwZWNpYWwgY2FzZSBiYWNrIGNvbXBhdCBzdXBwb3J0IGZvciBubyBwcmVmaXhcbiAgICBjb25zdCB1c2VkUHJlZml4ID0gdHlwZSA9PT0gJ3ByaXZhdGUnICYmIGxlbiA9PT0gMzIgPyBQcmVmaXguTk9ORSA6IHByZWZpeDtcbiAgICBjb25zdCBhbGdvcml0aG0gPSBLRVlfVFlQRVNbYCR7dHlwZX1fJHt1c2VkUHJlZml4fV8ke2xlbn1gXTtcbiAgICBpZiAoIWFsZ29yaXRobSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioa2V5RXJyb3IoeyBrZXksIHR5cGUsIGxlbiwgcHJlZml4OiB1c2VkUHJlZml4IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsZ29yaXRobTtcbn1cbmV4cG9ydHMuZ2V0QWxnb3JpdGhtRnJvbUtleSA9IGdldEFsZ29yaXRobUZyb21LZXk7XG5mdW5jdGlvbiBnZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5KGtleSkge1xuICAgIHJldHVybiBnZXRBbGdvcml0aG1Gcm9tS2V5KGtleSwgJ3B1YmxpYycpO1xufVxuZXhwb3J0cy5nZXRBbGdvcml0aG1Gcm9tUHVibGljS2V5ID0gZ2V0QWxnb3JpdGhtRnJvbVB1YmxpY0tleTtcbmZ1bmN0aW9uIGdldEFsZ29yaXRobUZyb21Qcml2YXRlS2V5KGtleSkge1xuICAgIHJldHVybiBnZXRBbGdvcml0aG1Gcm9tS2V5KGtleSwgJ3ByaXZhdGUnKTtcbn1cbmV4cG9ydHMuZ2V0QWxnb3JpdGhtRnJvbVByaXZhdGVLZXkgPSBnZXRBbGdvcml0aG1Gcm9tUHJpdmF0ZUtleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEFsZ29yaXRobUZyb21LZXkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-keypairs/dist/utils/getAlgorithmFromKey.js\n");

/***/ })

};
;