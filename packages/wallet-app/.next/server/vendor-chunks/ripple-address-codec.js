"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ripple-address-codec";
exports.ids = ["vendor-chunks/ripple-address-codec"];
exports.modules = {

/***/ "(ssr)/../../node_modules/ripple-address-codec/dist/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ripple-address-codec/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst utils_1 = __webpack_require__(/*! @xrplf/isomorphic/utils */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/utils/index.js\");\nconst xrp_codec_1 = __webpack_require__(/*! ./xrp-codec */ \"(ssr)/../../node_modules/ripple-address-codec/dist/xrp-codec.js\");\nObject.defineProperty(exports, \"codec\", ({ enumerable: true, get: function () { return xrp_codec_1.codec; } }));\nObject.defineProperty(exports, \"encodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } }));\nObject.defineProperty(exports, \"decodeSeed\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } }));\nObject.defineProperty(exports, \"encodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } }));\nObject.defineProperty(exports, \"decodeAccountID\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } }));\nObject.defineProperty(exports, \"encodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } }));\nObject.defineProperty(exports, \"decodeNodePublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } }));\nObject.defineProperty(exports, \"encodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } }));\nObject.defineProperty(exports, \"decodeAccountPublic\", ({ enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } }));\nObject.defineProperty(exports, \"isValidClassicAddress\", ({ enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } }));\nconst PREFIX_BYTES = {\n    // 5, 68\n    main: Uint8Array.from([0x05, 0x44]),\n    // 4, 147\n    test: Uint8Array.from([0x04, 0x93]),\n};\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295;\nfunction classicAddressToXAddress(classicAddress, tag, test) {\n    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);\n    return encodeXAddress(accountId, tag, test);\n}\nexports.classicAddressToXAddress = classicAddressToXAddress;\nfunction encodeXAddress(accountId, tag, test) {\n    if (accountId.length !== 20) {\n        // RIPEMD160 is 160 bits = 20 bytes\n        throw new Error('Account ID must be 20 bytes');\n    }\n    if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n        throw new Error('Invalid tag');\n    }\n    const theTag = tag || 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n    const flag = tag === false || tag == null ? 0 : 1;\n    /* eslint-disable no-bitwise ---\n     * need to use bitwise operations here */\n    const bytes = (0, utils_1.concat)([\n        test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n        accountId,\n        Uint8Array.from([\n            // 0x00 if no tag, 0x01 if 32-bit tag\n            flag,\n            // first byte\n            theTag & 0xff,\n            // second byte\n            (theTag >> 8) & 0xff,\n            // third byte\n            (theTag >> 16) & 0xff,\n            // fourth byte\n            (theTag >> 24) & 0xff,\n            0,\n            0,\n            0,\n            // four zero bytes (reserved for 64-bit tags)\n            0,\n        ]),\n    ]);\n    /* eslint-enable no-bitwise */\n    return xrp_codec_1.codec.encodeChecked(bytes);\n}\nexports.encodeXAddress = encodeXAddress;\nfunction xAddressToClassicAddress(xAddress) {\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const { accountId, tag, test } = decodeXAddress(xAddress);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);\n    return {\n        classicAddress,\n        tag,\n        test,\n    };\n}\nexports.xAddressToClassicAddress = xAddressToClassicAddress;\nfunction decodeXAddress(xAddress) {\n    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);\n    /* eslint-disable @typescript-eslint/naming-convention --\n     * TODO 'test' should be something like 'isTest', do this later\n     */\n    const test = isUint8ArrayForTestAddress(decoded);\n    /* eslint-enable @typescript-eslint/naming-convention */\n    const accountId = decoded.slice(2, 22);\n    const tag = tagFromUint8Array(decoded);\n    return {\n        accountId,\n        tag,\n        test,\n    };\n}\nexports.decodeXAddress = decodeXAddress;\nfunction isUint8ArrayForTestAddress(buf) {\n    const decodedPrefix = buf.slice(0, 2);\n    if ((0, utils_1.equal)(PREFIX_BYTES.main, decodedPrefix)) {\n        return false;\n    }\n    if ((0, utils_1.equal)(PREFIX_BYTES.test, decodedPrefix)) {\n        return true;\n    }\n    throw new Error('Invalid X-address: bad prefix');\n}\nfunction tagFromUint8Array(buf) {\n    const flag = buf[22];\n    if (flag >= 2) {\n        // No support for 64-bit tags at this time\n        throw new Error('Unsupported X-address');\n    }\n    if (flag === 1) {\n        // Little-endian to big-endian\n        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;\n    }\n    if (flag !== 0) {\n        throw new Error('flag must be zero to indicate no tag');\n    }\n    if (!(0, utils_1.equal)((0, utils_1.hexToBytes)('0000000000000000'), buf.slice(23, 23 + 8))) {\n        throw new Error('remaining bytes must be zero');\n    }\n    return false;\n}\nfunction isValidXAddress(xAddress) {\n    try {\n        decodeXAddress(xAddress);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidXAddress = isValidXAddress;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsc0JBQXNCLEdBQUcsZ0NBQWdDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsdUJBQXVCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUMvWSxnQkFBZ0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMsb0ZBQWE7QUFDekMseUNBQXdDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQzdHLDhDQUE2QyxFQUFFLHFDQUFxQyxrQ0FBa0MsRUFBQztBQUN2SCw4Q0FBNkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDdkgsbURBQWtELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2pJLG1EQUFrRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNqSSxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksb0RBQW1ELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ25JLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSx1REFBc0QsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDekkseURBQXdELEVBQUUscUNBQXFDLDZDQUE2QyxFQUFDO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0B2aW5kZXgvd2FsbGV0LWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC9pbmRleC5qcz9iZGE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkWEFkZHJlc3MgPSBleHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZXhwb3J0cy54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmVuY29kZVhBZGRyZXNzID0gZXhwb3J0cy5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MgPSBleHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGV4cG9ydHMuZGVjb2RlQWNjb3VudElEID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmRlY29kZVNlZWQgPSBleHBvcnRzLmVuY29kZVNlZWQgPSBleHBvcnRzLmNvZGVjID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAeHJwbGYvaXNvbW9ycGhpYy91dGlsc1wiKTtcbmNvbnN0IHhycF9jb2RlY18xID0gcmVxdWlyZShcIi4veHJwLWNvZGVjXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29kZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmNvZGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlU2VlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZVNlZWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZVNlZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVBY2NvdW50SURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRJRDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZUFjY291bnRJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW5jb2RlTm9kZVB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlTm9kZVB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlY29kZU5vZGVQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmRlY29kZU5vZGVQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVBY2NvdW50UHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVBY2NvdW50UHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQWNjb3VudFB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudFB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRDbGFzc2ljQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuaXNWYWxpZENsYXNzaWNBZGRyZXNzOyB9IH0pO1xuY29uc3QgUFJFRklYX0JZVEVTID0ge1xuICAgIC8vIDUsIDY4XG4gICAgbWFpbjogVWludDhBcnJheS5mcm9tKFsweDA1LCAweDQ0XSksXG4gICAgLy8gNCwgMTQ3XG4gICAgdGVzdDogVWludDhBcnJheS5mcm9tKFsweDA0LCAweDkzXSksXG59O1xuY29uc3QgTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQgPSA0Mjk0OTY3Mjk1O1xuZnVuY3Rpb24gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzKGNsYXNzaWNBZGRyZXNzLCB0YWcsIHRlc3QpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSAoMCwgeHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKShjbGFzc2ljQWRkcmVzcyk7XG4gICAgcmV0dXJuIGVuY29kZVhBZGRyZXNzKGFjY291bnRJZCwgdGFnLCB0ZXN0KTtcbn1cbmV4cG9ydHMuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzID0gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzO1xuZnVuY3Rpb24gZW5jb2RlWEFkZHJlc3MoYWNjb3VudElkLCB0YWcsIHRlc3QpIHtcbiAgICBpZiAoYWNjb3VudElkLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgLy8gUklQRU1EMTYwIGlzIDE2MCBiaXRzID0gMjAgYnl0ZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IElEIG11c3QgYmUgMjAgYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKHRhZyAhPT0gZmFsc2UgJiYgdGFnID4gTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZycpO1xuICAgIH1cbiAgICBjb25zdCB0aGVUYWcgPSB0YWcgfHwgMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiAtLSBQYXNzaW5nIG51bGwgaXMgYSBjb21tb24ganMgbWlzdGFrZVxuICAgIGNvbnN0IGZsYWcgPSB0YWcgPT09IGZhbHNlIHx8IHRhZyA9PSBudWxsID8gMCA6IDE7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAtLS1cbiAgICAgKiBuZWVkIHRvIHVzZSBiaXR3aXNlIG9wZXJhdGlvbnMgaGVyZSAqL1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuY29uY2F0KShbXG4gICAgICAgIHRlc3QgPyBQUkVGSVhfQllURVMudGVzdCA6IFBSRUZJWF9CWVRFUy5tYWluLFxuICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgICAgICAgICAvLyAweDAwIGlmIG5vIHRhZywgMHgwMSBpZiAzMi1iaXQgdGFnXG4gICAgICAgICAgICBmbGFnLFxuICAgICAgICAgICAgLy8gZmlyc3QgYnl0ZVxuICAgICAgICAgICAgdGhlVGFnICYgMHhmZixcbiAgICAgICAgICAgIC8vIHNlY29uZCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIC8vIHRoaXJkIGJ5dGVcbiAgICAgICAgICAgICh0aGVUYWcgPj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIC8vIGZvdXJ0aCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDI0KSAmIDB4ZmYsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAvLyBmb3VyIHplcm8gYnl0ZXMgKHJlc2VydmVkIGZvciA2NC1iaXQgdGFncylcbiAgICAgICAgICAgIDAsXG4gICAgICAgIF0pLFxuICAgIF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xuICAgIHJldHVybiB4cnBfY29kZWNfMS5jb2RlYy5lbmNvZGVDaGVja2VkKGJ5dGVzKTtcbn1cbmV4cG9ydHMuZW5jb2RlWEFkZHJlc3MgPSBlbmNvZGVYQWRkcmVzcztcbmZ1bmN0aW9uIHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyh4QWRkcmVzcykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHsgYWNjb3VudElkLCB0YWcsIHRlc3QgfSA9IGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGNvbnN0IGNsYXNzaWNBZGRyZXNzID0gKDAsIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRJRCkoYWNjb3VudElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGFzc2ljQWRkcmVzcyxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyA9IHhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcztcbmZ1bmN0aW9uIGRlY29kZVhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IHhycF9jb2RlY18xLmNvZGVjLmRlY29kZUNoZWNrZWQoeEFkZHJlc3MpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLVxuICAgICAqIFRPRE8gJ3Rlc3QnIHNob3VsZCBiZSBzb21ldGhpbmcgbGlrZSAnaXNUZXN0JywgZG8gdGhpcyBsYXRlclxuICAgICAqL1xuICAgIGNvbnN0IHRlc3QgPSBpc1VpbnQ4QXJyYXlGb3JUZXN0QWRkcmVzcyhkZWNvZGVkKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAqL1xuICAgIGNvbnN0IGFjY291bnRJZCA9IGRlY29kZWQuc2xpY2UoMiwgMjIpO1xuICAgIGNvbnN0IHRhZyA9IHRhZ0Zyb21VaW50OEFycmF5KGRlY29kZWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgdGFnLFxuICAgICAgICB0ZXN0LFxuICAgIH07XG59XG5leHBvcnRzLmRlY29kZVhBZGRyZXNzID0gZGVjb2RlWEFkZHJlc3M7XG5mdW5jdGlvbiBpc1VpbnQ4QXJyYXlGb3JUZXN0QWRkcmVzcyhidWYpIHtcbiAgICBjb25zdCBkZWNvZGVkUHJlZml4ID0gYnVmLnNsaWNlKDAsIDIpO1xuICAgIGlmICgoMCwgdXRpbHNfMS5lcXVhbCkoUFJFRklYX0JZVEVTLm1haW4sIGRlY29kZWRQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCgwLCB1dGlsc18xLmVxdWFsKShQUkVGSVhfQllURVMudGVzdCwgZGVjb2RlZFByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBYLWFkZHJlc3M6IGJhZCBwcmVmaXgnKTtcbn1cbmZ1bmN0aW9uIHRhZ0Zyb21VaW50OEFycmF5KGJ1Zikge1xuICAgIGNvbnN0IGZsYWcgPSBidWZbMjJdO1xuICAgIGlmIChmbGFnID49IDIpIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgNjQtYml0IHRhZ3MgYXQgdGhpcyB0aW1lXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgWC1hZGRyZXNzJyk7XG4gICAgfVxuICAgIGlmIChmbGFnID09PSAxKSB7XG4gICAgICAgIC8vIExpdHRsZS1lbmRpYW4gdG8gYmlnLWVuZGlhblxuICAgICAgICByZXR1cm4gYnVmWzIzXSArIGJ1ZlsyNF0gKiAweDEwMCArIGJ1ZlsyNV0gKiAweDEwMDAwICsgYnVmWzI2XSAqIDB4MTAwMDAwMDtcbiAgICB9XG4gICAgaWYgKGZsYWcgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmbGFnIG11c3QgYmUgemVybyB0byBpbmRpY2F0ZSBubyB0YWcnKTtcbiAgICB9XG4gICAgaWYgKCEoMCwgdXRpbHNfMS5lcXVhbCkoKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoJzAwMDAwMDAwMDAwMDAwMDAnKSwgYnVmLnNsaWNlKDIzLCAyMyArIDgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbWFpbmluZyBieXRlcyBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZFhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGlzVmFsaWRYQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-address-codec/dist/index.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-address-codec/dist/utils.js":
/*!*************************************************************!*\
  !*** ../../node_modules/ripple-address-codec/dist/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.concatArgs = exports.arrayEqual = void 0;\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nfunction arrayEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    return arr1.every((value, index) => value === arr2[index]);\n}\nexports.arrayEqual = arrayEqual;\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val) {\n    return typeof val === 'number';\n}\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\nfunction concatArgs(...args) {\n    return args.flatMap((arg) => {\n        return isScalar(arg) ? [arg] : Array.from(arg);\n    });\n}\nexports.concatArgs = concatArgs;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0B2aW5kZXgvd2FsbGV0LWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC91dGlscy5qcz8xMjk2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25jYXRBcmdzID0gZXhwb3J0cy5hcnJheUVxdWFsID0gdm9pZCAwO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHR3byBzZXF1ZW5jZXMgKGUuZy4gQXJyYXlzIG9mIG51bWJlcnMpIGFyZSBlcXVhbC5cbiAqXG4gKiBAcGFyYW0gYXJyMSAtIE9uZSBvZiB0aGUgYXJyYXlzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0gYXJyMiAtIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICovXG5mdW5jdGlvbiBhcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjEuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUgPT09IGFycjJbaW5kZXhdKTtcbn1cbmV4cG9ydHMuYXJyYXlFcXVhbCA9IGFycmF5RXF1YWw7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIHNjYWxhclxuICpcbiAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzU2NhbGFyKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICogQ29uY2F0ZW5hdGUgYWxsIGBhcmd1bWVudHNgIGludG8gYSBzaW5nbGUgYXJyYXkuIEVhY2ggYXJndW1lbnQgY2FuIGJlIGVpdGhlclxuICogYSBzaW5nbGUgZWxlbWVudCBvciBhIHNlcXVlbmNlLCB3aGljaCBoYXMgYSBgbGVuZ3RoYCBwcm9wZXJ0eSBhbmQgc3VwcG9ydHNcbiAqIGVsZW1lbnQgcmV0cmlldmFsIHZpYSBzZXF1ZW5jZVtpeF0uXG4gKlxuICogPiBjb25jYXRBcmdzKDEsIFsyLCAzXSwgVWludDhBcnJheS5mcm9tKFs0LDVdKSwgbmV3IFVpbnQ4QXJyYXkoWzYsIDddKSk7XG4gKiBbMSwyLDMsNCw1LDYsN11cbiAqXG4gKiBAcGFyYW0gYXJncyAtIENvbmNhdGVuYXRlIG9mIHRoZXNlIGFyZ3MgaW50byBhIHNpbmdsZSBhcnJheS5cbiAqIEByZXR1cm5zIEFycmF5IG9mIGNvbmNhdGVuYXRlZCBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gY29uY2F0QXJncyguLi5hcmdzKSB7XG4gICAgcmV0dXJuIGFyZ3MuZmxhdE1hcCgoYXJnKSA9PiB7XG4gICAgICAgIHJldHVybiBpc1NjYWxhcihhcmcpID8gW2FyZ10gOiBBcnJheS5mcm9tKGFyZyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbmNhdEFyZ3MgPSBjb25jYXRBcmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-address-codec/dist/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ripple-address-codec/dist/xrp-codec.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ripple-address-codec/dist/xrp-codec.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Codec class\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;\nconst base_1 = __webpack_require__(/*! @scure/base */ \"(ssr)/../../node_modules/@scure/base/lib/index.js\");\nconst sha256_1 = __webpack_require__(/*! @xrplf/isomorphic/sha256 */ \"(ssr)/../../node_modules/@xrplf/isomorphic/dist/sha256/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/../../node_modules/ripple-address-codec/dist/utils.js\");\nclass Codec {\n    constructor(options) {\n        this._sha256 = options.sha256;\n        this._codec = base_1.base58xrp;\n    }\n    /**\n     * Encoder.\n     *\n     * @param bytes - Uint8Array of data to encode.\n     * @param opts - Options object including the version bytes and the expected length of the data to encode.\n     */\n    encode(bytes, opts) {\n        const versions = opts.versions;\n        return this._encodeVersioned(bytes, versions, opts.expectedLength);\n    }\n    /**\n     * Decoder.\n     *\n     * @param base58string - Base58Check-encoded string to decode.\n     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n     */\n    /* eslint-disable max-lines-per-function --\n     * TODO refactor */\n    decode(base58string, opts) {\n        var _a;\n        const versions = opts.versions;\n        const types = opts.versionTypes;\n        const withoutSum = this.decodeChecked(base58string);\n        if (versions.length > 1 && !opts.expectedLength) {\n            throw new Error('expectedLength is required because there are >= 2 possible versions');\n        }\n        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;\n        const payloadLength = (_a = opts.expectedLength) !== null && _a !== void 0 ? _a : withoutSum.length - versionLengthGuess;\n        const versionBytes = withoutSum.slice(0, -payloadLength);\n        const payload = withoutSum.slice(-payloadLength);\n        for (let i = 0; i < versions.length; i++) {\n            /* eslint-disable @typescript-eslint/consistent-type-assertions --\n             * TODO refactor */\n            const version = Array.isArray(versions[i])\n                ? versions[i]\n                : [versions[i]];\n            if ((0, utils_1.arrayEqual)(versionBytes, version)) {\n                return {\n                    version,\n                    bytes: payload,\n                    type: types ? types[i] : null,\n                };\n            }\n            /* eslint-enable @typescript-eslint/consistent-type-assertions */\n        }\n        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');\n    }\n    encodeChecked(bytes) {\n        const check = this._sha256(this._sha256(bytes)).slice(0, 4);\n        return this._encodeRaw(Uint8Array.from((0, utils_1.concatArgs)(bytes, check)));\n    }\n    decodeChecked(base58string) {\n        const intArray = this._decodeRaw(base58string);\n        if (intArray.byteLength < 5) {\n            throw new Error('invalid_input_size: decoded data must have length >= 5');\n        }\n        if (!this._verifyCheckSum(intArray)) {\n            throw new Error('checksum_invalid');\n        }\n        return intArray.slice(0, -4);\n    }\n    _encodeVersioned(bytes, versions, expectedLength) {\n        if (!checkByteLength(bytes, expectedLength)) {\n            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +\n                ' Ensure that the bytes are a Uint8Array.');\n        }\n        return this.encodeChecked((0, utils_1.concatArgs)(versions, bytes));\n    }\n    _encodeRaw(bytes) {\n        return this._codec.encode(Uint8Array.from(bytes));\n    }\n    /* eslint-enable max-lines-per-function */\n    _decodeRaw(base58string) {\n        return this._codec.decode(base58string);\n    }\n    _verifyCheckSum(bytes) {\n        const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4);\n        const checksum = bytes.slice(-4);\n        return (0, utils_1.arrayEqual)(computed, checksum);\n    }\n}\n/**\n * XRP codec\n */\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0;\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23;\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21;\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c;\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b];\nconst codecOptions = {\n    sha256: sha256_1.sha256,\n};\nconst codecWithXrpAlphabet = new Codec(codecOptions);\nexports.codec = codecWithXrpAlphabet;\n// entropy is a Uint8Array of size 16\n// type is 'ed25519' or 'secp256k1'\nfunction encodeSeed(entropy, type) {\n    if (!checkByteLength(entropy, 16)) {\n        throw new Error('entropy must have length 16');\n    }\n    const opts = {\n        expectedLength: 16,\n        // for secp256k1, use `FAMILY_SEED`\n        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n    };\n    // prefixes entropy with version bytes\n    return codecWithXrpAlphabet.encode(entropy, opts);\n}\nexports.encodeSeed = encodeSeed;\nfunction decodeSeed(seed, opts = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n}) {\n    return codecWithXrpAlphabet.decode(seed, opts);\n}\nexports.decodeSeed = decodeSeed;\nfunction encodeAccountID(bytes) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountID = encodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.encodeAddress = encodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeAccountID(accountId) {\n    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };\n    return codecWithXrpAlphabet.decode(accountId, opts).bytes;\n}\nexports.decodeAccountID = decodeAccountID;\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexports.decodeAddress = decodeAccountID;\n/* eslint-enable import/no-unused-modules */\nfunction decodeNodePublic(base58string) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeNodePublic = decodeNodePublic;\nfunction encodeNodePublic(bytes) {\n    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeNodePublic = encodeNodePublic;\nfunction encodeAccountPublic(bytes) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.encode(bytes, opts);\n}\nexports.encodeAccountPublic = encodeAccountPublic;\nfunction decodeAccountPublic(base58string) {\n    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };\n    return codecWithXrpAlphabet.decode(base58string, opts).bytes;\n}\nexports.decodeAccountPublic = decodeAccountPublic;\nfunction isValidClassicAddress(address) {\n    try {\n        decodeAccountID(address);\n    }\n    catch (_error) {\n        return false;\n    }\n    return true;\n}\nexports.isValidClassicAddress = isValidClassicAddress;\nfunction checkByteLength(bytes, expectedLength) {\n    return 'byteLength' in bytes\n        ? bytes.byteLength === expectedLength\n        : bytes.length === expectedLength;\n}\n//# sourceMappingURL=xrp-codec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QveHJwLWNvZGVjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGFBQWE7QUFDN1MsZUFBZSxtQkFBTyxDQUFDLHNFQUFhO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLGlHQUEwQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyw0RUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0B2aW5kZXgvd2FsbGV0LWFwcC8uLi8uLi9ub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanM/MmJlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZWMgY2xhc3NcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZUFkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZXhwb3J0cy5kZWNvZGVTZWVkID0gZXhwb3J0cy5lbmNvZGVTZWVkID0gZXhwb3J0cy5jb2RlYyA9IHZvaWQgMDtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkB4cnBsZi9pc29tb3JwaGljL3NoYTI1NlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIENvZGVjIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NoYTI1NiA9IG9wdGlvbnMuc2hhMjU2O1xuICAgICAgICB0aGlzLl9jb2RlYyA9IGJhc2VfMS5iYXNlNTh4cnA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXMgLSBVaW50OEFycmF5IG9mIGRhdGEgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGVzIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIHRvIGVuY29kZS5cbiAgICAgKi9cbiAgICBlbmNvZGUoYnl0ZXMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgb3B0cy5leHBlY3RlZExlbmd0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZTU4c3RyaW5nIC0gQmFzZTU4Q2hlY2stZW5jb2RlZCBzdHJpbmcgdG8gZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGUocykgYW5kIHRoZSBleHBlY3RlZCBsZW5ndGggb2YgdGhlIGRhdGEgYWZ0ZXIgZGVjb2RpbmcuXG4gICAgICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAtLVxuICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICBkZWNvZGUoYmFzZTU4c3RyaW5nLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICBjb25zdCB0eXBlcyA9IG9wdHMudmVyc2lvblR5cGVzO1xuICAgICAgICBjb25zdCB3aXRob3V0U3VtID0gdGhpcy5kZWNvZGVDaGVja2VkKGJhc2U1OHN0cmluZyk7XG4gICAgICAgIGlmICh2ZXJzaW9ucy5sZW5ndGggPiAxICYmICFvcHRzLmV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkTGVuZ3RoIGlzIHJlcXVpcmVkIGJlY2F1c2UgdGhlcmUgYXJlID49IDIgcG9zc2libGUgdmVyc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ZXJzaW9uTGVuZ3RoR3Vlc3MgPSB0eXBlb2YgdmVyc2lvbnNbMF0gPT09ICdudW1iZXInID8gMSA6IHZlcnNpb25zWzBdLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IChfYSA9IG9wdHMuZXhwZWN0ZWRMZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpdGhvdXRTdW0ubGVuZ3RoIC0gdmVyc2lvbkxlbmd0aEd1ZXNzO1xuICAgICAgICBjb25zdCB2ZXJzaW9uQnl0ZXMgPSB3aXRob3V0U3VtLnNsaWNlKDAsIC1wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHdpdGhvdXRTdW0uc2xpY2UoLXBheWxvYWRMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnNpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnMgLS1cbiAgICAgICAgICAgICAqIFRPRE8gcmVmYWN0b3IgKi9cbiAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBBcnJheS5pc0FycmF5KHZlcnNpb25zW2ldKVxuICAgICAgICAgICAgICAgID8gdmVyc2lvbnNbaV1cbiAgICAgICAgICAgICAgICA6IFt2ZXJzaW9uc1tpXV07XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxzXzEuYXJyYXlFcXVhbCkodmVyc2lvbkJ5dGVzLCB2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlcyA/IHR5cGVzW2ldIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvY29uc2lzdGVudC10eXBlLWFzc2VydGlvbnMgKi9cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZlcnNpb25faW52YWxpZDogdmVyc2lvbiBieXRlcyBkbyBub3QgbWF0Y2ggYW55IG9mIHRoZSBwcm92aWRlZCB2ZXJzaW9uKHMpJyk7XG4gICAgfVxuICAgIGVuY29kZUNoZWNrZWQoYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSB0aGlzLl9zaGEyNTYodGhpcy5fc2hhMjU2KGJ5dGVzKSkuc2xpY2UoMCwgNCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVSYXcoVWludDhBcnJheS5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKGJ5dGVzLCBjaGVjaykpKTtcbiAgICB9XG4gICAgZGVjb2RlQ2hlY2tlZChiYXNlNThzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaW50QXJyYXkgPSB0aGlzLl9kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKTtcbiAgICAgICAgaWYgKGludEFycmF5LmJ5dGVMZW5ndGggPCA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfaW5wdXRfc2l6ZTogZGVjb2RlZCBkYXRhIG11c3QgaGF2ZSBsZW5ndGggPj0gNScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q2hlY2tTdW0oaW50QXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtX2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50QXJyYXkuc2xpY2UoMCwgLTQpO1xuICAgIH1cbiAgICBfZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKCFjaGVja0J5dGVMZW5ndGgoYnl0ZXMsIGV4cGVjdGVkTGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkX3BheWxvYWRfbGVuZ3RoOiBieXRlcy5sZW5ndGggZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWRMZW5ndGguJyArXG4gICAgICAgICAgICAgICAgJyBFbnN1cmUgdGhhdCB0aGUgYnl0ZXMgYXJlIGEgVWludDhBcnJheS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVDaGVja2VkKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKHZlcnNpb25zLCBieXRlcykpO1xuICAgIH1cbiAgICBfZW5jb2RlUmF3KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlYy5lbmNvZGUoVWludDhBcnJheS5mcm9tKGJ5dGVzKSk7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxpbmVzLXBlci1mdW5jdGlvbiAqL1xuICAgIF9kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2RlYy5kZWNvZGUoYmFzZTU4c3RyaW5nKTtcbiAgICB9XG4gICAgX3ZlcmlmeUNoZWNrU3VtKGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5fc2hhMjU2KHRoaXMuX3NoYTI1NihieXRlcy5zbGljZSgwLCAtNCkpKS5zbGljZSgwLCA0KTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBieXRlcy5zbGljZSgtNCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5hcnJheUVxdWFsKShjb21wdXRlZCwgY2hlY2tzdW0pO1xuICAgIH1cbn1cbi8qKlxuICogWFJQIGNvZGVjXG4gKi9cbi8vIGJhc2U1OCBlbmNvZGluZ3M6IGh0dHBzOi8veHJwbC5vcmcvYmFzZTU4LWVuY29kaW5ncy5odG1sXG4vLyBBY2NvdW50IGFkZHJlc3MgKDIwIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9JRCA9IDA7XG4vLyBBY2NvdW50IHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgQUNDT1VOVF9QVUJMSUNfS0VZID0gMHgyMztcbi8vIDMzOyBTZWVkIHZhbHVlIChmb3Igc2VjcmV0IGtleXMpICgxNiBieXRlcylcbmNvbnN0IEZBTUlMWV9TRUVEID0gMHgyMTtcbi8vIDI4OyBWYWxpZGF0aW9uIHB1YmxpYyBrZXkgKDMzIGJ5dGVzKVxuY29uc3QgTk9ERV9QVUJMSUMgPSAweDFjO1xuLy8gWzEsIDIyNSwgNzVdXG5jb25zdCBFRDI1NTE5X1NFRUQgPSBbMHgwMSwgMHhlMSwgMHg0Yl07XG5jb25zdCBjb2RlY09wdGlvbnMgPSB7XG4gICAgc2hhMjU2OiBzaGEyNTZfMS5zaGEyNTYsXG59O1xuY29uc3QgY29kZWNXaXRoWHJwQWxwaGFiZXQgPSBuZXcgQ29kZWMoY29kZWNPcHRpb25zKTtcbmV4cG9ydHMuY29kZWMgPSBjb2RlY1dpdGhYcnBBbHBoYWJldDtcbi8vIGVudHJvcHkgaXMgYSBVaW50OEFycmF5IG9mIHNpemUgMTZcbi8vIHR5cGUgaXMgJ2VkMjU1MTknIG9yICdzZWNwMjU2azEnXG5mdW5jdGlvbiBlbmNvZGVTZWVkKGVudHJvcHksIHR5cGUpIHtcbiAgICBpZiAoIWNoZWNrQnl0ZUxlbmd0aChlbnRyb3B5LCAxNikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRyb3B5IG11c3QgaGF2ZSBsZW5ndGggMTYnKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IDE2LFxuICAgICAgICAvLyBmb3Igc2VjcDI1NmsxLCB1c2UgYEZBTUlMWV9TRUVEYFxuICAgICAgICB2ZXJzaW9uczogdHlwZSA9PT0gJ2VkMjU1MTknID8gRUQyNTUxOV9TRUVEIDogW0ZBTUlMWV9TRUVEXSxcbiAgICB9O1xuICAgIC8vIHByZWZpeGVzIGVudHJvcHkgd2l0aCB2ZXJzaW9uIGJ5dGVzXG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShlbnRyb3B5LCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlU2VlZCA9IGVuY29kZVNlZWQ7XG5mdW5jdGlvbiBkZWNvZGVTZWVkKHNlZWQsIG9wdHMgPSB7XG4gICAgdmVyc2lvblR5cGVzOiBbJ2VkMjU1MTknLCAnc2VjcDI1NmsxJ10sXG4gICAgdmVyc2lvbnM6IFtFRDI1NTE5X1NFRUQsIEZBTUlMWV9TRUVEXSxcbiAgICBleHBlY3RlZExlbmd0aDogMTYsXG59KSB7XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShzZWVkLCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVjb2RlU2VlZCA9IGRlY29kZVNlZWQ7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50SUQoYnl0ZXMpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzIC0tLVxuICogdW5jbGVhciB3aHkgdGhpcyBpcyBhbGlhc2VkIGJ1dCB3ZSBzaG91bGQga2VlcCBpdCBpbiBjYXNlIHNvbWVvbmUgZWxzZSBpc1xuICogaW1wb3J0aW5nIGl0IHdpdGggdGhlIGFsaWFzZWQgbmFtZSAqL1xuZXhwb3J0cy5lbmNvZGVBZGRyZXNzID0gZW5jb2RlQWNjb3VudElEO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXMgKi9cbmZ1bmN0aW9uIGRlY29kZUFjY291bnRJRChhY2NvdW50SWQpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfSURdLCBleHBlY3RlZExlbmd0aDogMjAgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGFjY291bnRJZCwgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAtLS1cbiAqIHVuY2xlYXIgd2h5IHRoaXMgaXMgYWxpYXNlZCBidXQgd2Ugc2hvdWxkIGtlZXAgaXQgaW4gY2FzZSBzb21lb25lIGVsc2UgaXNcbiAqIGltcG9ydGluZyBpdCB3aXRoIHRoZSBhbGlhc2VkIG5hbWUgKi9cbmV4cG9ydHMuZGVjb2RlQWRkcmVzcyA9IGRlY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzICovXG5mdW5jdGlvbiBkZWNvZGVOb2RlUHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZGVjb2RlKGJhc2U1OHN0cmluZywgb3B0cykuYnl0ZXM7XG59XG5leHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBkZWNvZGVOb2RlUHVibGljO1xuZnVuY3Rpb24gZW5jb2RlTm9kZVB1YmxpYyhieXRlcykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbTk9ERV9QVUJMSUNdLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlTm9kZVB1YmxpYyA9IGVuY29kZU5vZGVQdWJsaWM7XG5mdW5jdGlvbiBlbmNvZGVBY2NvdW50UHVibGljKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX1BVQkxJQ19LRVldLCBleHBlY3RlZExlbmd0aDogMzMgfTtcbiAgICByZXR1cm4gY29kZWNXaXRoWHJwQWxwaGFiZXQuZW5jb2RlKGJ5dGVzLCBvcHRzKTtcbn1cbmV4cG9ydHMuZW5jb2RlQWNjb3VudFB1YmxpYyA9IGVuY29kZUFjY291bnRQdWJsaWM7XG5mdW5jdGlvbiBkZWNvZGVBY2NvdW50UHVibGljKGJhc2U1OHN0cmluZykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbQUNDT1VOVF9QVUJMSUNfS0VZXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShiYXNlNThzdHJpbmcsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZGVjb2RlQWNjb3VudFB1YmxpYztcbmZ1bmN0aW9uIGlzVmFsaWRDbGFzc2ljQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlQWNjb3VudElEKGFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRDbGFzc2ljQWRkcmVzcyA9IGlzVmFsaWRDbGFzc2ljQWRkcmVzcztcbmZ1bmN0aW9uIGNoZWNrQnl0ZUxlbmd0aChieXRlcywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICByZXR1cm4gJ2J5dGVMZW5ndGgnIGluIGJ5dGVzXG4gICAgICAgID8gYnl0ZXMuYnl0ZUxlbmd0aCA9PT0gZXhwZWN0ZWRMZW5ndGhcbiAgICAgICAgOiBieXRlcy5sZW5ndGggPT09IGV4cGVjdGVkTGVuZ3RoO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHJwLWNvZGVjLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ripple-address-codec/dist/xrp-codec.js\n");

/***/ })

};
;